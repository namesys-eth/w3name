import{fromString as e}from"uint8arrays/from-string";import{toString as t}from"uint8arrays/to-string";import{keys as n}from"libp2p-crypto";import{identity as r}from"multiformats/hashes/identity";import{base36 as i}from"multiformats/bases/base36";import{CID as a}from"multiformats/cid";import*as s from"multiformats/hashes/digest";import*as o from"ipns";import*as c from"cborg";import u from"./service.mjs";import m from"@web-std/fetch";const d=114,y=()=>new Date(Date.now()+31536e6).toISOString(),l=new u;class w{constructor(e){this._pubKey=e}get bytes(){const e=s.create(r.code,this._pubKey.bytes);return a.createV1(d,e).bytes}toString(){const e=s.create(r.code,this._pubKey.bytes);return a.createV1(d,e).toString(i)}}class p extends w{constructor(e){super(e.public),this._privKey=e}get key(){return this._privKey}}async function f(){const e=await n.generateKeyPair("Ed25519",2048);return new p(e)}function h(e){const t=a.parse(e,i);if(t.code!==d)throw new Error(`Invalid key, expected 114 codec code but got ${t.code}`);const r=n.unmarshalPublicKey(s.decode(t.multihash.bytes).bytes);return new w(r)}async function v(e){const t=await n.unmarshalPrivateKey(e);return new p(t)}async function b(e,t){return new _(e,t,0n,y())}async function g(e,t){const n=e.sequence+1n;return new _(e.name,t,n,y())}class _{constructor(e,t,n,r){if(this._name=e,"string"!=typeof t)throw new Error("invalid value");if(this._value=t,"bigint"!=typeof n)throw new Error("invalid sequence number");if(this._sequence=n,"string"!=typeof r)throw new Error("invalid validity");this._validity=r}get name(){return this._name}get value(){return this._value}get sequence(){return this._sequence}get validity(){return this._validity}static encode(e){return c.encode({name:e._name.toString(),value:e._value,sequence:e._sequence,validity:e._validity})}static decode(e){const t=c.decode(e),n=h(t.name);return new _(n,t.value,BigInt(t.sequence),t.validity)}}async function q(n,r,i=l){const a=new URL(`name/${n.name.toString()}`,i.endpoint),s=await o.create(r,e(n.value),n.sequence,new Date(n.validity).getTime()-Date.now());await i.waitForRateLimit(),await K(m(a.toString(),{method:"POST",body:t(o.marshal(s),"base64pad")}))}async function S(r,i=l){const c=new URL(`name/${r.toString()}`,i.endpoint);await i.waitForRateLimit();const u=await K(m(c.toString())),{record:d}=await u.json(),y=o.unmarshal(e(d,"base64pad")),w=a.decode(r.bytes),p=n.unmarshalPublicKey(s.decode(w.multihash.bytes).bytes);return await o.validate(p,y),new _(r,t(y.value),y.sequence,t(y.validity))}async function K(e){const t=await e;if(t.ok)return t;let n;try{const e=await t.json();n=new Error(e.message)}catch(e){n=new Error(`unexpected response from API, cannot parse error response. Received status: ${t.status}`)}throw n}export{w as Name,_ as Revision,p as WritableName,f as create,v as from,g as increment,h as parse,q as publish,S as resolve,b as v0};
//# sourceMappingURL=index.mjs.map
